# 操作系统第三次实验

杨博涵 张耕嘉 刘嘉昊

## 练习1：完善中断处理 （需要编程）

> 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。
>
> 要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

### 实现过程

1. **处理时钟中断**：时钟中断属于操作系统中的一种定时中断，它通过硬件定时器周期性地触发。操作系统每处理一次时钟中断时，都会执行时钟中断处理函数，我们需要在这个处理函数中进行计时和控制。

2. **中断处理函数 `interrupt_handler`**：

   - 我们首先根据中断的 `cause` 来判断是否是时钟中断。
   - 时钟中断是通过 `IRQ_S_TIMER` 来触发的，程序将处理该中断并执行以下几个步骤：
     1. 调用 `clock_set_next_event()` 设置下次时钟中断。
     2. 累加 `ticks` 计数器。
     3. 每当 `ticks` 达到100时，调用 `print_ticks()` 打印 "100 ticks"。
     4. 记录打印次数 `printed`，当 `printed` 达到10时，调用 `sbi_shutdown()` 进行关机。

3. **具体代码实现**：
    以下是修改后的时钟中断处理代码：

   ```c
   void interrupt_handler(struct trapframe *tf) {
       intptr_t cause = (tf->cause << 1) >> 1;
       switch (cause) {
   		//......
           case IRQ_S_TIMER:
               {
                   static int printed = 0;
                   clock_set_next_event();//发生这次时钟中断的时候，我们要设置下一次时钟中断
                   if (++ticks % TICK_NUM == 0) {
                       print_ticks();
                       printed++;
                       if (printed >= 10) {
                           sbi_shutdown();
                       }
                   }
                   break;
               }
   		//......
       }
   }
   ```

### 定时器中断处理流程

1. **触发时钟中断**：
   - 操作系统中有一个硬件定时器，每隔一定时间（如每毫秒）触发一次时钟中断。
   - 每当时钟中断发生，CPU 会暂停当前任务，转到中断处理程序执行。
2. **时钟中断处理**：
   - 进入 `interrupt_handler` 函数，根据中断类型区分处理逻辑。
   - 如果是时钟中断（`IRQ_S_TIMER`），则执行设置下次中断、计数、打印和关机的操作。
3. **每100次时钟中断打印一次**：
   - 通过一个 `ticks` 变量记录经过的时钟中断次数，每达到100次时，调用 `print_ticks()` 打印 "100 ticks"。
4. **关机**：
   - 当打印次数累计到10次时，操作系统调用 `sbi_shutdown()` 进行关机。

## 扩展练习 Challenge1：描述与理解中断流程

>回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

### ucore 中处理中断异常的完整流程

ucore 中处理中断异常的流程是一个从硬件自动行为到软件处理再到恢复执行的完整过程。当异常或中断发生时，硬件首先自动保存关键状态到控制寄存器：将当前程序计数器保存到 sepc 寄存器，异常原因保存到 scause 寄存器，相关地址信息保存到 stval 寄存器，然后跳转到 stvec 寄存器预先设置的中断向量地址。

#### 阶段1.硬件自动响应

```c
// 硬件自动完成以下操作：
sepc = current_pc;                    // 保存当前程序计数器
scause = exception_cause;             // 设置异常原因编码
stval = additional_info;              // 存储附加信息（如错误地址）
pc = stvec;                          // 跳转到中断向量地址
```

在软件层面，流程首先通过 __alltraps 入口保存完整的执行上下文，然后将控制权交给 C 语言编写的分发函数，根据中断类型进行具体处理，最后恢复上下文并返回到被中断的代码继续执行。

#### 阶段二.进入 __alltraps 入口点

__alltraps 是预先设置在 stvec 寄存器中的异常处理入口地址，所有类型的中断和异常都会首先跳转到这里开始处理。

````assembly
.globl __alltraps
    .align(2)
__alltraps:
    # 这是所有异常/中断的统一入口点
    # 此时硬件已经设置了 sepc, scause, stval
    # 程序执行流跳转到这里开始软件处理
````

#### 阶段3：参数传递与函数调用

SAVE_ALL 能够保存完整上下文,通过 move a0, sp 实现汇编层到C语言层的参数传递，让C函数能够访问完整的异常上下文信息。

```assembly
SAVE_ALL    # 展开宏，保存所有寄存器到栈帧
    # 具体保存内容包括：
    # - 所有32个通用寄存器 x0-x31
    # - 4个关键控制状态寄存器
    # - 原始栈指针值
    # 总共36个寄存器，占用36*REGBYTES的栈空间
move  a0, sp      # 将栈帧指针作为第一个参数
    jal trap          # 跳转到C语言处理函数
    # 调用约定：a0寄存器传递 trapframe 指针
    # 此时 sp 指向包含所有寄存器值的 trapframe 结构
```

#### 阶段4.c语言处理异常

在C语言层面根据 scause 寄存器的高位判断是中断还是异常，分别进入不同的处理路径，根据不同的异常原因执行相应的处理代码。

```c
void trap(struct trapframe *tf) {
    trap_dispatch(tf);  // 根据异常原因进行分发
}

static inline void trap_dispatch(struct trapframe *tf) {
    if ((intptr_t)tf->cause < 0) {
        interrupt_handler(tf);   // 中断处理分支
    } else {
        exception_handler(tf);   // 异常处理分支
    }
}
```

#### 阶段5.回复上下文

```assembly
.globl __trapret
__trapret:
    # 这是从C函数返回后的继续执行点
    # 准备恢复被中断的上下文
RESTORE_ALL    # 展开宏，从栈帧恢复所有寄存器
    # 恢复内容包括：
    # - 所有通用寄存器 x1-x31 (x0除外)
    # - sstatus 和 sepc 控制寄存器
    # - 最后恢复栈指针 x2(sp)
sret    # 特权返回指令，硬件自动：
            # - 从 sepc 恢复程序计数器
            # - 恢复中断使能状态
            # - 返回到原来的特权级
```

__trapret 是异常返回的入口点，负责恢复之前保存的上下文并返回到被中断的程序。RESTORE_ALL确保程序能够恢复到被中断时刻的完整状态继续执行。sret 是 RISC-V 的监督模式返回指令，硬件利用之前保存的状态信息完成执行流的恢复。

### move a0, sp 的目的

move a0, sp 这条指令位于 trapentry.S 文件的 __alltraps 标签下，在 SAVE_ALL 宏完成寄存器保存之后，在调用 jal trap 跳转到 C 处理函数之前。它的核心目的是实现汇编层与 C 语言层之间的参数传递桥梁，将当前栈指针的值传递给 C 语言的陷阱处理函数作为参数。

```assembly
    .globl __alltraps
    .align(2)
__alltraps:
    SAVE_ALL          # 首先保存所有寄存器到栈空间
                      # 此时 sp 指向包含所有寄存器值的 trapframe 结构
    move  a0, sp      # ← 关键指令：将 trapframe 指针传递给 C 函数
    jal trap          # 跳转到 C 语言的 trap 处理函数
    # sp should be the same as before "jal trap"
```

在 RISC-V 架构的调用约定中，a0 寄存器专门用于传递第一个参数。执行 move a0, sp 后，a0 寄存器包含了指向 trapframe 结构的指针，这个结构在栈上包含了所有保存的寄存器值。当调用 trap(struct trapframe *tf) 时，C 函数就能通过这个指针访问到完整的中断上下文。这相当于在 C 代码中直接调用 trap((struct trapframe *)sp)，实现了汇编环境与 C 环境的无缝衔接。

### SAVE_ALL 中寄存器保存在栈中的位置

SAVE_ALL 中寄存器保存在栈中的位置是通过固定偏移量布局来确定的，这种布局严格对应着 C 语言中 struct trapframe 结构体的内存布局。每个寄存器在栈帧中的位置都是预先计算好的固定偏移量，基于 REGBYTES（通常是 4 字节或 8 字节）作为基本单位进行计算。这种布局设计的智慧在于：通用寄存器 x0-x31 占据前 32 个位置（0-31REGBYTES），控制状态寄存器占据后续的 4 个位置（32-35REGBYTES）。整个布局总共 36 个寄存器位置，形成了完整的中断上下文快照。

```assembly
.macro SAVE_ALL
    csrw sscratch, sp
    addi sp, sp, -36 * REGBYTES  # 预留 36 个寄存器空间
    
    # 通用寄存器按编号顺序保存
    STORE x0, 0*REGBYTES(sp)     # zero 寄存器
    STORE x1, 1*REGBYTES(sp)     # ra (返回地址)
    STORE x3, 3*REGBYTES(sp)     # gp (全局指针)
    # ... 中间寄存器 x4-x31
    STORE x31, 31*REGBYTES(sp)   # 最后一个通用寄存器
    
    # 控制状态寄存器保存在高位偏移处
    csrrw s0, sscratch, x0       # 获取原来的 sp 值
    csrr s1, sstatus            # 状态寄存器
    csrr s2, sepc               # 异常程序计数器
    csrr s3, sbadaddr           # 错误地址
    csrr s4, scause             # 异常原因
    
    STORE s0, 2*REGBYTES(sp)    # 原始 sp 保存在 x2 的位置
    STORE s1, 32*REGBYTES(sp)   # sstatus
    STORE s2, 33*REGBYTES(sp)   # sepc
    STORE s3, 34*REGBYTES(sp)   # sbadaddr
    STORE s4, 35*REGBYTES(sp)   # scause
    .endm
```

### 对于任何中断，__alltraps 中都需要保存所有寄存器吗？

对于任何中断，__alltraps 中确实需要保存所有寄存器，这是基于操作系统可靠性、安全性和简单性等多重考量下的必要设计选择。虽然从性能角度看似有些浪费，但这种统一保存的策略确保了系统在各种极端情况下的正确行为。必要性：

首先，中断的不可预测性要求全面保存。中断可能在任何指令执行期间发生，而编译器在优化过程中可能将关键数据保存在任何通用寄存器中，无法预先知道哪些寄存器包含重要数据，哪些可以忽略。其次，处理程序的通用性要求完整上下文。不同的中断处理程序可能需要访问不同的寄存器集合，系统调用需要参数寄存器，页错误需要访问出错的地址寄存器，而调试异常可能需要检查多个状态寄存器。第三，RISC-V 架构的软件负责机制要求显式保存。与某些架构不同，RISC-V 不会自动保存任何通用寄存器，这给了软件最大的灵活性，但也要求软件承担完全的责任。最重要的是，安全隔离的需求要求万无一失。在用户态与内核态切换时，必须确保没有任何用户态寄存器信息泄漏到内核，也没有内核寄存器信息泄漏到用户态，完整保存是实现这种隔离的基础。

虽然保存所有 36 个寄存器确实有性能开销，但这种开销相对于确保系统正确性、安全性和可维护性而言是完全可以接受的。这种设计体现了操作系统内核开发中"正确性优先于性能"的原则。

## 扩展练习 Challenge2：理解上下文切换机制

> 回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

### csrw sscratch, sp; csrrw s0, sscratch, x0 操作解析

这两条指令实现了一个精巧的栈指针管理机制，主要目的是保存原始栈指针并为处理嵌套异常做好准备。

```assembly
csrw sscratch, sp      # 将当前栈指针 sp 的值保存到 sscratch 寄存器
csrrw s0, sscratch, x0 # 将 sscratch 的值读取到 s0，同时将 x0(零) 写入 sscratch(清空)
```

csrw sscratch, sp 将当前栈指针的值备份到 sscratch 寄存器中，因为在 SAVE_ALL 中紧接着会分配新的栈空间用于保存寄存器上下文，原来的栈指针就会丢失。第二条指令 csrrw s0, sscratch, x0 执行一个原子操作：将 sscratch 中保存的原始栈指针值读取到 s0 寄存器中，同时将零值写入 sscratch。这样做的巧妙之处在于，清空 sscratch 可以标识当前已处于异常处理环境中，如果在此期间发生新的异常，异常处理程序通过检查 sscratch 为零就能识别这种情况，避免对栈指针进行重复保存和错误处理

#### 效果

主要目的是保存原始栈指针并为可能的递归异常做准备：

1.保存原始栈指针：在 SAVE_ALL 开始时，sp 即将被修改指向新的 trapframe，需要先保存原始值

2.处理递归异常：如果在异常处理过程中发生新的异常，sscratch 为 0 表示当前已在内核态，避免栈的重复切换

3.统一上下文管理：确保无论来自用户态还是内核态，都能正确保存和恢复栈上下文

###  stval、scause 等 CSR 保存但不还原的意义

这些寄存器在 RISC-V 特权架构中被设计为只读或瞬时状态寄存器，而不是需要持久保存的执行状态：

```c
// RISC-V 特权规范定义的寄存器行为：
scause: Read-only, set by hardware on exception entry
stval:  Read-only or writeable only in specific cases
// 与之对比：
sepc:   Read-write, must be preserved for correct execution
sstatus: Read-write, contains critical mode and interrupt enable bits
```

在架构中，scause 负责记录当前异常的原因代码，stval 提供异常相关的附加信息（如页错误的虚拟地址），它们描述的是异常事件本身的特征而非处理器的持久执行状态。在异常处理完成后，这些事件信息就失去了意义，因为下一次异常会由硬件自动设置全新的值，恢复旧值只会造成信息混乱且违反架构语义。如果尝试恢复操作，可能会被架构禁止或者产生未定义行为。

这样做带来了显著的好处：首先在性能上节省了不必要的寄存器恢复操作，提升了异常返回的速度；其次在代码简洁性上避免了冗余操作，减少了潜在错误；最重要的是保持了语义的正确性，确保异常处理逻辑清晰可靠，符合 RISC-V 特权架构的设计。

## 扩展练习Challenge3：完善异常中断

>编程完善在触发一条非法指令异常和断点异常，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

### 实现过程

#### 异常处理函数 `exception_handler`

在操作系统中，异常处理是对程序运行中发生的错误或特殊情况的响应。当 CPU 遇到无法继续执行的指令时，会触发相应的异常。我们需要对以下两种异常进行处理：

1. **非法指令异常（Illegal instruction）**：
   - 该异常通常是因为程序执行了无法识别或非法的指令。我们需要捕获该异常并输出相关信息。
   - 在此异常发生时，我们需要输出：
     - 异常类型：`Illegal instruction`
     - 异常触发的指令地址：`tf->epc`（异常发生时的程序计数器）
2. **断点异常（Breakpoint）**：
   - 该异常通常用于调试，程序执行到断点指令时触发。
   - 在此异常发生时，我们需要输出：
     - 异常类型：`breakpoint`
     - 异常触发的指令地址：`tf->epc`（异常发生时的程序计数器）

以下是代码实现：

```C
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
        case CAUSE_MISALIGNED_FETCH:
            break;
        case CAUSE_FAULT_FETCH:
            break;
        case CAUSE_ILLEGAL_INSTRUCTION:
            // 非法指令异常处理
            cprintf("Illegal instruction caught at 0x%08x\n", tf->epc);
            cprintf("Exception type: Illegal instruction\n");
            tf->epc += 4;
            break;
        case CAUSE_BREAKPOINT:
            // 断点异常处理
            cprintf("ebreak caught at 0x%08x\n", tf->epc);
            cprintf("Exception type: breakpoint\n");
            tf->epc += 4;
            break;
 		//......
    }
}
```

#### 代码解析

1. **非法指令异常处理（`CAUSE_ILLEGAL_INSTRUCTION`）**：
   - 当触发非法指令异常时，程序会输出异常类型为 "Illegal instruction" 以及异常发生的指令地址 。指令地址通过 `tf->epc` 获取。
2. **断点异常处理（`CAUSE_BREAKPOINT`）**：
   - 当触发断点异常时，程序会输出异常类型为 "breakpoint" 以及异常发生的指令地址 `tf->epc`。
   - 断点异常通常出现在调试阶段，允许开发者在某个特定的地方暂停程序的执行，因此需要记录断点发生的位置。
3. **更新 `tf->epc`**：
   - 对于这两种异常，我们都需要更新 `tf->epc`，即异常发生时的程序计数器。通常情况下，`epc` 会指向当前异常指令的地址，而我们通过 `tf->epc += 4` 来调整到下一个指令的位置，继续执行后续操作。

#### 异常类型与输出

1. **非法指令异常输出**：

   - 当发生非法指令异常时，输出如下信息：

     ```
     Illegal instruction caught at 0x(异常指令地址)
     Exception type: Illegal instruction
     ```

2. **断点异常输出**：

   - 当发生断点异常时，输出如下信息：

     ```
     ebreak caught at 0x(异常指令地址)
     Exception type: breakpoint
     ```