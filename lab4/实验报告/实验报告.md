# 操作系统第四次实验

杨博涵 张耕嘉 刘嘉昊

## 练习0：填写已有实验

> 本实验依赖实验2/3。请把你做的实验2/3的代码填入本实验中代码中有“LAB2”,“LAB3”的注释相应部分。

将lab3中`trap.c`补充的代码添加到lab4中

```
    case IRQ_S_TIMER:
        // "All bits besides SSIP and USIP in the sip register are
        // read-only." -- privileged spec1.9.1, 4.1.4, p59
        // In fact, Call sbi_set_timer will clear STIP, or you can clear it
        // directly.
        // clear_csr(sip, SIP_STIP);

        /*LAB3 请补充你在lab3中的代码 */ 
        {
            static int printed = 0;
            clock_set_next_event();//发生这次时钟中断的时候，我们要设置下一次时钟中断
            if (++ticks % TICK_NUM == 0) {
                print_ticks();
                printed++;
                if (printed >= 10) {
                    sbi_shutdown();
                }
            }
            break;
        }
```

## 练习1：分配并初始化一个进程控制块（需要编码）

> alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
>
> 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>
> - 请说明proc_struct中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

### 实现过程

```c
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&(proc->context), 0, sizeof(struct context));
        proc->tf = NULL;
        // 使用内核页目录的物理地址
        proc->pgdir = boot_pgdir_pa;
        proc->flags = 0;
        memset(proc->name, 0, PROC_NAME_LEN + 1);
        
    }
    return proc;
}
```

在 `alloc_proc` 函数中，我们首先通过 `kmalloc` 分配了一个 `struct proc_struct` 类型的内存块。这是我们需要返回的新进程控制块，内存分配成功后，我们对其中的各个字段进行了初始化。以下是初始化的详细步骤：

1. **`state`**: 设置为 `PROC_UNINIT`，表示进程处于未初始化状态。
2. **`pid`**: 设置为 `-1`，表示进程还没有分配一个有效的进程ID。
3. **`runs`**: 设置为 `0`，表示进程尚未运行。
4. **`kstack`**: 设置为 `0`，表示尚未分配内核栈。
5. **`need_resched`**: 设置为 `0`，表示该进程没有需要调度的标志。
6. **`parent`**: 设置为 `NULL`，表示该进程没有父进程。
7. **`mm`**: 设置为 `NULL`，表示该进程没有内存管理结构。
8. **`context`**: 使用 `memset` 将 `context` 字段清零，表示该进程的上下文信息尚未设置。
9. **`tf`**: 设置为 `NULL`，表示该进程没有保存的中断帧。
10. **`pgdir`**: 设置为 `boot_pgdir_pa`，表示该进程使用内核的物理页目录。
11. **`flags`**: 设置为 `0`，表示进程没有设置特殊标志。
12. **`name`**: 使用 `memset` 将进程名清零，表示该进程的名称为空。

通过这些初始化，`alloc_proc` 函数创建了一个新进程控制块，并准备好相关资源，确保后续的进程调度和管理操作能够正确进行。

### `struct context context` 和 `struct trapframe *tf` 变量的含义与作用

在 `proc_struct` 结构体中，`context` 和 `tf` 成员变量分别承担了以下作用：

1. **`struct context context`**:

   * 含义：`struct context` 结构体用于保存进程切换时的上下文信息。上下文信息通常包括进程当前执行时的寄存器状态，这些寄存器包括程序计数器（`ra`）、堆栈指针（`sp`）以及一组通用寄存器（`s0` 到 `s11`）。这些寄存器存储了进程在运行时的状态数据，包括当前指令的地址、当前函数的返回地址、局部变量以及函数调用的返回地址等。操作系统需要保存这些状态，以便能够在进程被中断或挂起时，能在恢复时从中断发生前的状态继续执行。

     具体来说，`context` 包含以下寄存器：

     * **`ra`**: 返回地址寄存器（Return Address），通常用于存储当前执行函数调用的返回地址。
     * **`sp`**: 堆栈指针（Stack Pointer），指向当前进程的堆栈顶部。
     * **`s0` 到 `s11`**: 一组保存进程状态的通用寄存器（s0~s11），这些寄存器用于保存函数调用期间的局部变量和其他需要保存的状态信息。

   * 作用：在进程**切换**（即从一个进程切换到另一个进程）时，操作系统需要**保存当前进程的上下文信息**，以便在之后能够恢复进程的执行状态。这意味着操作系统会将当前进程的寄存器值（如程序计数器、堆栈指针和其他寄存器的值）保存到 `context` 结构体中。

     当操作系统决定**恢复**进程的执行时，它会从该进程的 `context` 中恢复这些寄存器值，使得进程能够从中断发生前的状态继续执行。例如，当操作系统决定重新调度该进程时，CPU 会从进程的 `context` 中读取之前保存的寄存器值，恢复程序计数器（`ra`）和堆栈指针（`sp`），并将 CPU 状态恢复到进程暂停时的状态。

2. **`struct trapframe \*tf`**:

   * 含义：`tf` 是一个指向 `trapframe` 结构体的指针，`trapframe` 用于保存进程在中断或异常发生时的寄存器状态。当进程受到中断（如硬件中断、软件中断）或异常（如非法指令、页面错误）时，操作系统会将进程的寄存器状态保存在 `trapframe` 结构体中，以便中断处理程序能够访问这些信息，处理中断或异常。

     具体来说，`trapframe` 包含了以下字段：

     * **`gpr`**: `struct pushregs` 类型，保存了进程的通用寄存器（General Purpose Registers）。这些寄存器保存了进程的状态，包括局部变量和参数等。
     * **`status`**: 保存进程的状态寄存器值，通常用于记录中断使能、程序状态等。
     * **`epc`**: 程序计数器（Program Counter），保存发生中断或异常时的指令地址。操作系统会根据 `epc` 确定中断或异常发生的位置。
     * **`badvaddr`**: 发生异常时的无效地址，通常用于处理地址错误异常，如访问非法内存地址时。
     * **`cause`**: 记录异常的原因。这个字段可以帮助操作系统识别中断或异常的类型，以便采取相应的处理措施。

   * 作用：在本实验中，`tf` 用于**保存进程在发生系统调用或硬件中断时的状态信息**。操作系统通过 `trapframe` 来处理中断或异常，确保在中断处理结束后能够恢复进程的正常执行。

     具体而言，当进程发生中断或异常时，操作系统会将当前进程的寄存器值（包括程序计数器、状态寄存器、无效地址等）保存到 `trapframe` 中。中断或异常处理程序可以通过访问 `trapframe` 中保存的信息，了解中断发生时的进程状态，并根据异常类型采取相应的处理措施。

     中断处理程序结束后，操作系统会根据 `trapframe` 中保存的寄存器值恢复进程的状态，确保进程能够从中断发生之前的状态继续执行。因此，`trapframe` 对进程的中断处理至关重要，它保证了操作系统能够正确处理进程中的中断或异常，并在处理完毕后恢复进程的执行。

## 练习2：为新创建的内核线程分配资源（需要编码）

>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用**do_fork**函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们**实际需要"fork"的东西就是stack和trapframe**。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：
>
>- 调用alloc_proc，首先获得一块用户信息块。
>- 为进程分配一个内核栈。
>- 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
>- 复制原进程上下文到新进程
>- 将新进程添加到进程列表
>- 唤醒新进程
>- 返回新进程号
>
>请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>
>- 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

### 设计实现过程

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 2313725
    if ((proc = alloc_proc()) == NULL)
    {
        goto fork_out;
    }

    if (setup_kstack(proc) != 0)
    {
        goto bad_fork_cleanup_proc;
    }

    if (copy_mm(clone_flags, proc) != 0)
    {
        goto bad_fork_cleanup_kstack;
    }

    copy_thread(proc, stack, tf);

    bool intr_flag;
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        proc->pgdir = boot_pgdir_pa; // 设置为内核页目录
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);

    wakeup_proc(proc);

    ret = proc->pid;
    
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

`do_fork` 函数的核心功能是创建一个新的进程或内核线程，下面是该函数的执行过程及其关键步骤：

1. **调用 `alloc_proc` 创建进程控制块**:
   - `alloc_proc()` 为新进程分配内存并初始化进程控制块。它创建了一个包含进程基本信息的结构体 `proc_struct`，并且设置了一些默认值（如 `pid`、`state` 等）。
2. **为新进程分配内核栈**:
   - `setup_kstack(proc)` 为新进程分配内核栈，保证进程能够正常执行。在内核线程中，每个进程都需要一个内核栈，以便在进程切换和中断时保存现场信息。
3. **复制原进程的内存管理信息**:
   - `copy_mm(clone_flags, proc)` 根据 `clone_flags` 来判断是否需要复制原进程的内存管理信息。对于内核线程，`copy_mm` 将根据 `CLONE_VM` 标志来决定是否共享内存管理结构，否则会复制原进程的内存管理结构。
4. **复制原进程的上下文信息**:
   - `copy_thread(proc, stack, tf)` 将原进程的上下文（如 trapframe）复制到新进程的内核栈中。通过这种方式，确保新进程的执行状态与原进程一致，允许在执行中断或系统调用时恢复正确的状态。
5. **将新进程添加到进程列表**:
   - 使用 `hash_proc(proc)` 和 `list_add(&proc_list, &(proc->list_link))` 将新进程添加到进程哈希表和进程列表中。这使得操作系统能够管理并调度新进程。
6. **唤醒新进程**:
   - 调用 `wakeup_proc(proc)` 将新进程的状态设置为 `PROC_RUNNABLE`，意味着该进程已经准备好运行，可以由调度器调度。
7. **返回新进程的 PID**:
   - 在成功创建新进程并分配资源后，`do_fork` 返回新进程的 PID，这个 PID 用于标识新进程。

通过以上步骤，`do_fork` 实现了内核线程的创建过程，并为其分配了必要的资源。

### ucore 是否为每个新 `fork` 的线程分配唯一的 ID？

是的，`ucore` 为每个新 `fork` 的线程分配了唯一的 ID。在 `do_fork` 函数中，调用了 `get_pid()` 来为新进程分配一个唯一的进程 ID（PID）。该函数通过生成一个新的 PID 来确保每个进程都有一个唯一的标识符。每次调用 `do_fork` 时，`get_pid()` 都会返回一个新的、未使用的 PID，从而避免了 PID 重复的情况。

因此，`ucore` 确保了每个新创建的进程或线程都有一个唯一的 ID，这对于操作系统管理进程、调度进程以及资源分配至关重要。

## 练习3：编写proc_run 函数（需要编码）

> proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：
>
> - 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
> - 禁用中断。你可以使用`/kern/sync/sync.h`中定义好的宏`local_intr_save(x)`和`local_intr_restore(x)`来实现关、开中断。
> - 切换当前进程为要运行的进程。
> - 切换页表，以便使用新进程的地址空间。`/libs/riscv.h`中提供了`lsatp(unsigned int pgdir)`函数，可实现修改SATP寄存器值的功能。
> - 实现上下文切换。`/kern/process`中已经预先编写好了`switch.S`，其中定义了`switch_to()`函数。可实现两个进程的context切换。
> - 允许中断。
>
> 请回答如下问题：
>
> - 在本实验的执行过程中，创建且运行了几个内核线程？
>
> 完成代码编写后，编译并运行代码：make qemu

### 设计实现过程

`proc_run` 函数的核心功能是将当前进程切换到指定的进程并执行。具体步骤如下：

1. **检查当前进程与目标进程是否相同**:
   - 首先，我们检查当前运行的进程（`current`）是否与目标进程（`proc`）相同。如果相同，则无需进行切换，因为进程已经在 CPU 上运行。
2. **禁用中断**:
   - 调用 `local_intr_save(intr_flag)` 来禁用当前 CPU 的中断。这是为了保证在进程切换过程中，不会被外部中断打断，从而确保上下文切换的原子性。
3. **更新当前进程**:
   - 如果进程需要切换，我们将 `current` 指针指向新进程 `proc`，表示新的进程将成为当前正在运行的进程。
4. **切换页表**:
   - 调用 `lsatp(proc->pgdir)` 来切换到新进程的页表。`lsatp` 函数会修改 SATP 寄存器的值，以便让 CPU 使用新进程的地址空间。这样，新进程的虚拟地址就会映射到对应的物理地址。
5. **执行上下文切换**:
   - 调用 `switch_to(&(prev->context), &(proc->context))` 执行上下文切换。`switch_to` 函数会将当前进程的上下文保存到 `prev->context`，并加载新进程的上下文 `proc->context`，从而实现从一个进程切换到另一个进程的效果。
6. **恢复中断**:
   - 在完成上下文切换后，我们调用 `local_intr_restore(intr_flag)` 来恢复中断，使得新的进程能够响应外部中断。

### 代码实现

```c
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        bool intr_flag;
        struct proc_struct *prev = current;
        
        // 1. 禁用中断
        local_intr_save(intr_flag);
        
        // 2. 更新当前进程
        current = proc;
        
        // 3. 切换页表到新进程的地址空间
        lsatp(proc->pgdir);
        
        // 4. 执行上下文切换
        switch_to(&(prev->context), &(proc->context));
        
        // 5. 恢复中断（在 switch_to 返回后执行）
        local_intr_restore(intr_flag);
    }
}
```

### 功能分析

- `proc_run` 的主要功能是将目标进程的上下文切换到 CPU 上并开始执行。
- 中断的禁用和恢复确保了在上下文切换过程中不会被打断，从而保证切换的原子性和一致性。
- 页表切换通过 `lsatp` 函数实现，这样可以确保 CPU 正在访问新进程的地址空间，而不是旧进程的地址空间。
- `switch_to` 函数实现了上下文切换，它是进程调度的核心部分，通过保存和恢复寄存器状态实现了进程之间的切换。

### 回答问题：

#### 在本实验的执行过程中，创建且运行了几个内核线程？

在本实验的执行过程中，在`proc_init`函数中创建且运行了 **两个内核线程**：

1. **idleproc**:
   - 这是第一个内核线程，由 `proc_init` 函数中的 `alloc_proc` 创建。
   - 它的 `pid` 被设置为 `0`，名字为 `"idle"`。
   - 它是内核的空闲线程，负责在没有其他任务时保持 CPU 空闲。
2. **initproc**:
   - 这是第二个内核线程，由 `kernel_thread` 函数创建。
   - 它的 `pid` 被设置为 `1`，名字为 `"init"`。
   - 它的入口函数是 `init_main`，在其中打印了 `"Hello world!!"` 等信息。

## 扩展练习Challenge：

>1. 说明语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`是如何实现开关中断的？
>
>2. 深入理解不同分页模式的工作原理（思考题）
>
>   get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
>
>   - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
>   - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

### challenge1

说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？

这两个语句的位置：

```cpp
sync.h

#ifndef __KERN_SYNC_SYNC_H__
#define __KERN_SYNC_SYNC_H__

#include <defs.h>
#include <intr.h>
#include <riscv.h>

static inline bool __intr_save(void) {
    if (read_csr(sstatus) & SSTATUS_SIE) {
        intr_disable();
        return 1;
    }
    return 0;
}

static inline void __intr_restore(bool flag) {
    if (flag) {
        intr_enable();
    }
}

#define local_intr_save(x) \
    do {                   \
        x = __intr_save(); \
    } while (0)
#define local_intr_restore(x) __intr_restore(x);

#endif /* !__KERN_SYNC_SYNC_H__ */
```

当调用`local_intr_save`时，会读取`sstatus`寄存器，通过读取 sstatus 寄存器的 SIE 位来判断当前中断状态，如果该位为 1，则说明中断是能进行的，则调用 intr_disable 将该位置 0，并返回 true 保存到 intr_flag; 如果该位为 0，则说明中断此时已经不能进行，则返回 0，将 intr_flag 赋值为 0。这样就可以保证之后的代码执行时不会发生中断。

当需要恢复中断时，调用 local_intr_restore，需要判断 intr_flag 的值，如果其值为 1，则需要调用 intr_enable 将 sstatus 寄存器的 SIE 位置 1，否则该位依然保持 0。以此来恢复调用 local_intr_save 之前的 SIE 的值。

### challenge2

深入理解不同分页模式的工作原理（思考题）:

get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

#### 问题1：get_pte() 代码分析

```cpp
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {
    // 第一段代码 - 处理第一级页目录
    pde_t *pdep1 = &pgdir[PDX1(la)];
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
    
    // 第二段代码 - 处理第二级页目录  
    pde_t *pdep0 = &((pte_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
    if (!(*pdep0 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
    
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
}
```

**两段代码相像的原因：**

**1.RISC-V 的多级页表采用递归设计,决定了每一级的处理逻辑必须相似：**

- 每一级页表的结构完全相同
- 每一级都存储下一级页表的物理页号
- 每一级的查找和分配逻辑基本一致

**2.统一的处理模式：**

对于 N 级页表，处理逻辑都是：

```markdown
// 伪代码
for (每一级 i from 最高级 to 最低级) {
    1.第 i 级索引在页表中查找
    2. 如果该页表项无效：
        a. 如果需要创建：分配物理页，初始化，设置页表项
        b. 否则返回NULL
    3. 进入下一级页表
}
```

**3.SV39 的具体实现**

在 SV39 中（3级页表）：

第一段处理 VPN[2]（第2级）

第二段处理 VPN[1]（第1级）

最后返回处理 VPN[0]（第0级）的 PTE

如果是 SV48（4级页表），就会有三段相似的代码。



**SV32, SV39, SV48 的异同**

| 特性         | SV32                     | SV39                               | SV48                                           |
| :----------- | ------------------------ | ---------------------------------- | ---------------------------------------------- |
| 虚拟地址位宽 | 32位                     | 39位                               | 48位                                           |
| 物理地址位宽 | 34位                     | 56位                               | 56位                                           |
| 页表级数     | 2级                      | 3级                                | 4级                                            |
| 索引位宽     | VPN[1]:10位, VPN[0]:10位 | VPN[2]:9位, VPN[1]:9位, VPN[0]:9位 | VPN[3]:9位, VPN[2]:9位, VPN[1]:9位, VPN[0]:9位 |

#### **问题2：**

**当前合并写法的优点**

当前将页表项查找和分配合并在`get_pte()`函数中的写法是合理的，这种设计在操作系统内核这种性能至上的环境中具有显著优势。它通过单次遍历页表同时完成查找和分配操作，避免了重复遍历的开销，保证了操作的原子性，适合内核中频繁的页表操作场景。虽然违反了单一职责原则，但在性能敏感的内核代码中，这种以性能优先的实用主义设计是恰当的选择，也符合许多成熟操作系统的实现方式。

**拆分开的必要性**
从软件工程角度考虑，确实有必要将查找和分配功能拆分开来。拆分后可以提高代码的可维护性和可测试性，消除当前存在的代码重复问题，让每个函数职责更加单一纯粹。查找函数可以专注于页表遍历逻辑，分配函数专门处理物理页分配和页表初始化，这样的设计更符合模块化原则，便于单独测试和调试，长期来看会显著提升代码质量和可扩展性，虽然会带来轻微的性能开销，但获得的工程效益是值得的。